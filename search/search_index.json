{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Piri \u00b6 Configurable Data Mapping for mortals Documentation | Source Code | Task Tracker Goal \u00b6 The goal of this library is to make JSON to JSON transformation/mapping configurable. We achieve this by using a simple but feature-rich JSON configuration which then also acts as a contract. Features \u00b6 Mapping with configuration File. Transforms JSON Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date Contributing \u00b6 Please see contribute Installation \u00b6 Info Package is on pypi. Use pip or poetry to install pip install piri poetry add piri Quickstart \u00b6 import simplejson from piri.mapper import map_data my_config = { 'name' : 'schema' , 'array' : False , 'objects' : [ { 'name' : 'invoices' , 'array' : True , 'path_to_iterable' : [ 'root' , 'invoices' ], 'attributes' : [ { 'name' : 'amount' , 'mappings' : [ { 'path' : [ 'invoices' , 'amount' ], }, ], 'casting' : { 'to' : 'decimal' , 'original_format' : 'integer_containing_decimals' , }, 'default' : 0 , }, { 'name' : 'debtor' , 'mappings' : [ { 'path' : [ 'root' , 'customer' , 'first_name' ], }, { 'path' : [ 'root' , 'customer' , 'last_name' ], }, ], 'separator' : ' ' , }, ], 'objects' : [], }, ], } example_data = { 'root' : { 'customer' : { 'first_name' : 'John' , 'last_name' : 'Smith' , }, 'invoices' : [ { 'amount' : 10050 , }, { 'amount' : 20050 , }, { 'amount' : - 15005 , }, ], }, } mapped_data = map_data ( example_data , my_config ) with open ( 'resultfile.json' , 'w' ) as output_file : output_file . write ( simplejson . dumps ( mapped_data . unwrap ())) contents of resultfile.json { \"invoices\" : [ { \"amount\" : 100.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : 200.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : -150.05 , \"debtor\" : \"John Smith\" } ] } Process \u00b6 The Process function tries to make it easy to run all steps in order. Since its a callable object then dependencies(functions) can be changed before calling. This is the execution order: validate configuration data configuration must be valid and also we apply some output formatting to the configuration data. run pre processing a pre_process function can be supplied that must change raw data to python dictionary if it isn't already map data run mapping function with the validated configuration and pre_processed data. this outputs a dictionary validate and marshall this loads the mapping result into a marshmallow Schema that will validate the data for us. after that it will return the dump(marshall) of the schema that can apply any output formatting rules needed. this is the only function that is required to provide when process is initiated. create output run provided output function. if none is provided it simply returns the dictionary. to provide an output function simply add it while initiating Process. with the argument _output=function. The function must receive dictionary and can return anything","title":"Home"},{"location":"#piri","text":"Configurable Data Mapping for mortals Documentation | Source Code | Task Tracker","title":"Piri"},{"location":"#goal","text":"The goal of this library is to make JSON to JSON transformation/mapping configurable. We achieve this by using a simple but feature-rich JSON configuration which then also acts as a contract.","title":"Goal"},{"location":"#features","text":"Mapping with configuration File. Transforms JSON Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date","title":"Features"},{"location":"#contributing","text":"Please see contribute","title":"Contributing"},{"location":"#installation","text":"Info Package is on pypi. Use pip or poetry to install pip install piri poetry add piri","title":"Installation"},{"location":"#quickstart","text":"import simplejson from piri.mapper import map_data my_config = { 'name' : 'schema' , 'array' : False , 'objects' : [ { 'name' : 'invoices' , 'array' : True , 'path_to_iterable' : [ 'root' , 'invoices' ], 'attributes' : [ { 'name' : 'amount' , 'mappings' : [ { 'path' : [ 'invoices' , 'amount' ], }, ], 'casting' : { 'to' : 'decimal' , 'original_format' : 'integer_containing_decimals' , }, 'default' : 0 , }, { 'name' : 'debtor' , 'mappings' : [ { 'path' : [ 'root' , 'customer' , 'first_name' ], }, { 'path' : [ 'root' , 'customer' , 'last_name' ], }, ], 'separator' : ' ' , }, ], 'objects' : [], }, ], } example_data = { 'root' : { 'customer' : { 'first_name' : 'John' , 'last_name' : 'Smith' , }, 'invoices' : [ { 'amount' : 10050 , }, { 'amount' : 20050 , }, { 'amount' : - 15005 , }, ], }, } mapped_data = map_data ( example_data , my_config ) with open ( 'resultfile.json' , 'w' ) as output_file : output_file . write ( simplejson . dumps ( mapped_data . unwrap ())) contents of resultfile.json { \"invoices\" : [ { \"amount\" : 100.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : 200.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : -150.05 , \"debtor\" : \"John Smith\" } ] }","title":"Quickstart"},{"location":"#process","text":"The Process function tries to make it easy to run all steps in order. Since its a callable object then dependencies(functions) can be changed before calling. This is the execution order: validate configuration data configuration must be valid and also we apply some output formatting to the configuration data. run pre processing a pre_process function can be supplied that must change raw data to python dictionary if it isn't already map data run mapping function with the validated configuration and pre_processed data. this outputs a dictionary validate and marshall this loads the mapping result into a marshmallow Schema that will validate the data for us. after that it will return the dump(marshall) of the schema that can apply any output formatting rules needed. this is the only function that is required to provide when process is initiated. create output run provided output function. if none is provided it simply returns the dictionary. to provide an output function simply add it while initiating Process. with the argument _output=function. The function must receive dictionary and can return anything","title":"Process"},{"location":"changelog/","text":"Version history \u00b6 We follow semantic Versions with first version released as 1.0.0 . We do this to prevent 0Ver and never getting to v1. All Breaking releases are major All Feature releases are minor Everything else: patch Version 1.0.0 Release: Piri Reis \u00b6 The first release focuses on key mapping functionality. We believe that is finding values from different places and combining them to one. Setting default values, Casting values, and applying if statements. This should suffice for a lot of usecases where one need to transform json into structurally different json. features \u00b6 Mapping with configuration File. Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date","title":"Changelog"},{"location":"changelog/#version-history","text":"We follow semantic Versions with first version released as 1.0.0 . We do this to prevent 0Ver and never getting to v1. All Breaking releases are major All Feature releases are minor Everything else: patch","title":"Version history"},{"location":"changelog/#version-100-release-piri-reis","text":"The first release focuses on key mapping functionality. We believe that is finding values from different places and combining them to one. Setting default values, Casting values, and applying if statements. This should suffice for a lot of usecases where one need to transform json into structurally different json.","title":"Version 1.0.0 Release: Piri Reis"},{"location":"changelog/#features","text":"Mapping with configuration File. Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date","title":"features"},{"location":"configuration/","text":"Configuration Json data \u00b6 The configuration governs not only where to find data, but also the structure of the output which will mirror the structure in the configuration json. The two main components of the configuration json is the object and attributes. An object can contain nested objects and/or attributes. In the attribute part of the file is where you actually tell the mapper where to find data. In the object you are deciding the structure and also telling the mapper if there are iterable data anywhere that needs to be iterated to create multiple instances. <span style=\"color: var(--md-primary-fg-color)\" <span style=\"color: var(--md-accent-fg-color)\"> Object \u00b6 An object has a name, it can have attributes, nested objects or a special type of objects called branching objects . It will also know if itself is an array and the path to where the input data can be iterated to create multiple objects. name type description comment name str name of the key it will get in parent object the root will not get a name array bool tells the mapper if this should be an array or not path_to_iterable array[str|int] path to itrable data where this and child parts of the configuration should be applied per iteration attributes array[ attribute ] An array of this objects attribute mappings objects array[ object ] Here you can nest more objects. branching_objects array[ branching object ] Array of a special kind of object rarely used { \"name\" : \"object_name\" , \"array\" : true , \"path_to_iterable\" : [ \"path\" , \"to\" , \"list\" ], \"objects\" : [], \"branching_objects\" : [], \"attributes\" : [] } Attribute \u00b6 The attributes are like 'color' of a car or 'amount' in an invoice. Attributes are have a name ('amount'), a number of mappings, separator, if statements, casting and a default value if all else fails. name type description default name str The name it will get in the parent object mappings array[ mapping ] list of mapping objects which is where to find data [] seperator str string to separate each value in case multiple are found in mapping step '' if_statements array[ if statement ] If statements that can change data based on conditions [] casting casting Lets you cast data to a spesific type [int, decimal, date] {} default Any If after all mapping, if statements and casting the result is None this value is used None { \"name\" : \"attribute_name\" , \"mappings\" : [], \"separator\" : \"\" , \"if_statements\" : [], \"casting\" : {}, \"default\" : \"default value\" } Mapping \u00b6 This is the only place where actual interaction with the input data is done. name type description default path array[str|int] path to data you want to retrieve. [] if_statements array[ if statement ] If statements that can change data based on conditions [] default Any If no value is found or value is None after if_statements then this value is used None Note either path or default must contain a something Explanation of path You add a list of strings or integers that will get you to your data. so for example if you needed to get to the second element in the list called my_list in the following json then your path will be [\"my_list\", 1] and you will get the value index1 { \"my_list\" : [ \"index0\" , \"index1\" ] } if_statements: list of if statements that can change the data depending on conditions default: a default value if none is found or value found is None { \"path\" : [ \"path\" , \"to\" , \"data\" ], \"if_statements\" : [], \"default\" : \"default\" } input({'path': { 'to': { 'data': 'value'}}}) -> 'value' input({'path': { 'does_not_exist'}}) -> 'default' input() -> 'default' If Statement \u00b6 This is where you can change found(or not found) data to something else based on a condition. They are chained in the sense that what the first one produces will be the input to the next one. Thus if you want the original value if the first one fails, then leave out otherwise name type description default condition \"is\"|\"not\"|\"contains\" What condition to use when checking value against target target str|number|bool Target what we do our condition against ie: value == target when condition is is then str|number|bool value that we will return if the condition is true otherwise str|number|bool Optional value that we can return if the condition is false None { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"first_type\" , \"otherwise\" : \"default_type\" } input('2') -> 'default_type' input('1') -> 'first_type' Casting object \u00b6 The casting object lets you cast whatever value is found to some new value. Currently integer, decimal and date are supported and original format is optional helper data that we need for some special cases where the format of the input value cannot be asserted automatically. name type description default to one of [\"integer\", \"decimal\", \"date\"] What type to cast the value to original_format \"integer_containing_decimals\" or spesific date format(see below)\" For some values we need to specify extra information in order to correctly cast it. None about original format Note When to is date then original_format is required . when to is original format description decimal integer_containing_decimals is used when some integer value should be casted to decimal and we need to divide it by 100 date yyyy.mm.dd yy.mm.dd yymmdd dd.mm.yyyy dd.mm.yy ddmmyy The format of the input date. . means any delimiter. Output is always iso-date yyyy-mm-dd Examples { \"to\" : \"decimal\" , \"original_format\" : \"integer_containing_decimals\" } \"10050\" -> Decimal(100.50) { \"to\" : \"date\" , \"original_format\" : \"ddmmyyyy\" } \"01012001\" -> \"2010-01-01\" Branching Object \u00b6 The branching object is a special object that does not have attributes or object childs but has a special branching_attributes child. The point of this object is to make sure that we can map data from different sources into the same element. for example, we have an object called \"extradata\" with the attributes 'name' and 'data'. This is kind of a field that can be many things. like 'name' = 'extra_address_line1', and another one with 'extra_address_line2'. This must then get its data from different places, and thats what these branching objects are for. name type description default name str Name of the object array bool if it should be an array or not path_to_iterable array[str, int] path to list [] branching_attributes array[array[ attribute ]] list of list of attributes where each list of attributes will create a branching object. Example { \"name\" : \"extradata\" , \"array\" : true , \"branching_attributes\" : [ [ { \"name\" : \"name\" , \"default\" : \"extra_address_line1\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line1\" , \"value\" ]}] } ], [ { \"name\" : \"name\" , \"default\" : \"extra_address_line2\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line2\" , \"value\" ]}] } ] ] } This will produce: { \"extradata\" : [ { \"name\" : \"extra_address_line1\" , \"data\" : \"address value 1\" }, { \"name\" : \"extra_address_line2\" , \"data\" : \"address value 2\" } ] }","title":"Configuration"},{"location":"configuration/#configuration-json-data","text":"The configuration governs not only where to find data, but also the structure of the output which will mirror the structure in the configuration json. The two main components of the configuration json is the object and attributes. An object can contain nested objects and/or attributes. In the attribute part of the file is where you actually tell the mapper where to find data. In the object you are deciding the structure and also telling the mapper if there are iterable data anywhere that needs to be iterated to create multiple instances. <span style=\"color: var(--md-primary-fg-color)\" <span style=\"color: var(--md-accent-fg-color)\">","title":"Configuration Json data"},{"location":"configuration/#object","text":"An object has a name, it can have attributes, nested objects or a special type of objects called branching objects . It will also know if itself is an array and the path to where the input data can be iterated to create multiple objects. name type description comment name str name of the key it will get in parent object the root will not get a name array bool tells the mapper if this should be an array or not path_to_iterable array[str|int] path to itrable data where this and child parts of the configuration should be applied per iteration attributes array[ attribute ] An array of this objects attribute mappings objects array[ object ] Here you can nest more objects. branching_objects array[ branching object ] Array of a special kind of object rarely used { \"name\" : \"object_name\" , \"array\" : true , \"path_to_iterable\" : [ \"path\" , \"to\" , \"list\" ], \"objects\" : [], \"branching_objects\" : [], \"attributes\" : [] }","title":"Object"},{"location":"configuration/#attribute","text":"The attributes are like 'color' of a car or 'amount' in an invoice. Attributes are have a name ('amount'), a number of mappings, separator, if statements, casting and a default value if all else fails. name type description default name str The name it will get in the parent object mappings array[ mapping ] list of mapping objects which is where to find data [] seperator str string to separate each value in case multiple are found in mapping step '' if_statements array[ if statement ] If statements that can change data based on conditions [] casting casting Lets you cast data to a spesific type [int, decimal, date] {} default Any If after all mapping, if statements and casting the result is None this value is used None { \"name\" : \"attribute_name\" , \"mappings\" : [], \"separator\" : \"\" , \"if_statements\" : [], \"casting\" : {}, \"default\" : \"default value\" }","title":"Attribute"},{"location":"configuration/#mapping","text":"This is the only place where actual interaction with the input data is done. name type description default path array[str|int] path to data you want to retrieve. [] if_statements array[ if statement ] If statements that can change data based on conditions [] default Any If no value is found or value is None after if_statements then this value is used None Note either path or default must contain a something Explanation of path You add a list of strings or integers that will get you to your data. so for example if you needed to get to the second element in the list called my_list in the following json then your path will be [\"my_list\", 1] and you will get the value index1 { \"my_list\" : [ \"index0\" , \"index1\" ] } if_statements: list of if statements that can change the data depending on conditions default: a default value if none is found or value found is None { \"path\" : [ \"path\" , \"to\" , \"data\" ], \"if_statements\" : [], \"default\" : \"default\" } input({'path': { 'to': { 'data': 'value'}}}) -> 'value' input({'path': { 'does_not_exist'}}) -> 'default' input() -> 'default'","title":"Mapping"},{"location":"configuration/#if-statement","text":"This is where you can change found(or not found) data to something else based on a condition. They are chained in the sense that what the first one produces will be the input to the next one. Thus if you want the original value if the first one fails, then leave out otherwise name type description default condition \"is\"|\"not\"|\"contains\" What condition to use when checking value against target target str|number|bool Target what we do our condition against ie: value == target when condition is is then str|number|bool value that we will return if the condition is true otherwise str|number|bool Optional value that we can return if the condition is false None { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"first_type\" , \"otherwise\" : \"default_type\" } input('2') -> 'default_type' input('1') -> 'first_type'","title":"If Statement"},{"location":"configuration/#casting-object","text":"The casting object lets you cast whatever value is found to some new value. Currently integer, decimal and date are supported and original format is optional helper data that we need for some special cases where the format of the input value cannot be asserted automatically. name type description default to one of [\"integer\", \"decimal\", \"date\"] What type to cast the value to original_format \"integer_containing_decimals\" or spesific date format(see below)\" For some values we need to specify extra information in order to correctly cast it. None about original format Note When to is date then original_format is required . when to is original format description decimal integer_containing_decimals is used when some integer value should be casted to decimal and we need to divide it by 100 date yyyy.mm.dd yy.mm.dd yymmdd dd.mm.yyyy dd.mm.yy ddmmyy The format of the input date. . means any delimiter. Output is always iso-date yyyy-mm-dd Examples { \"to\" : \"decimal\" , \"original_format\" : \"integer_containing_decimals\" } \"10050\" -> Decimal(100.50) { \"to\" : \"date\" , \"original_format\" : \"ddmmyyyy\" } \"01012001\" -> \"2010-01-01\"","title":"Casting object"},{"location":"configuration/#branching-object","text":"The branching object is a special object that does not have attributes or object childs but has a special branching_attributes child. The point of this object is to make sure that we can map data from different sources into the same element. for example, we have an object called \"extradata\" with the attributes 'name' and 'data'. This is kind of a field that can be many things. like 'name' = 'extra_address_line1', and another one with 'extra_address_line2'. This must then get its data from different places, and thats what these branching objects are for. name type description default name str Name of the object array bool if it should be an array or not path_to_iterable array[str, int] path to list [] branching_attributes array[array[ attribute ]] list of list of attributes where each list of attributes will create a branching object. Example { \"name\" : \"extradata\" , \"array\" : true , \"branching_attributes\" : [ [ { \"name\" : \"name\" , \"default\" : \"extra_address_line1\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line1\" , \"value\" ]}] } ], [ { \"name\" : \"name\" , \"default\" : \"extra_address_line2\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line2\" , \"value\" ]}] } ] ] } This will produce: { \"extradata\" : [ { \"name\" : \"extra_address_line1\" , \"data\" : \"address value 1\" }, { \"name\" : \"extra_address_line2\" , \"data\" : \"address value 2\" } ] }","title":"Branching Object"},{"location":"contributing/","text":"Contributing \u00b6 General Python info \u00b6 In this package we make extensive use of the Returns library . Its a library that forces us to try and write None free code and also wraps exceptions. It changes return values to Result 'Monads' with Success and Failure return containers or Maybe and Nothing containers. This helps us to do kind of railway-oriented-programming when working with mapping. We also use marshmallow , which is the tool we se to describe models and do validation. New Environment Tools \u00b6 Lately we have gotten a few great python environment managers. The first being PyEnv . Pyenv makes working with multiple versions of python easier. The second tool is Poetry . Poetry lets us create a lock file of all our dependencies, this means that both version of python and version of each dependency and its dependencies will be equal for everyone working on the project. It also uses the new pyproject.toml file which is the 'new' setup.py and requirements.txt in 1 file. Poetry also handles building and publishing. Setup the tools \u00b6 get pyenv - pyenv lets you work with multiple versions of python $ brew update $ brew install pyenv Put this command into the of ~/.bash_profile or run pyenv init to make sure where to put it for for example zsh. $ eval \"$(pyenv init -)\" install a version of python 3.7+: This installs a clean python to pyenvs folders and lets us reference that as a 'base' in our virtualenvs. $ pyenv install 3 .7.4 get poetry - dependency management: $ curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Make poetry create virtualenv in project folder. This makes it easier for IDE's to run correct virtualenv while debuging/running linters etc. $ poetry config settings.virtualenvs.in-project true Setup dev environment \u00b6 activate pyenv for the current shell $ pyenv shell 3 .7.4 This creates a virtualenv and installs all dependencies including dev: $ poetry install Now test that everything works. poetry run, runs a command in the virtualenv $ poetry run pytest initialize pre-commit hooks for git $ poetry run pre-commit install","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#general-python-info","text":"In this package we make extensive use of the Returns library . Its a library that forces us to try and write None free code and also wraps exceptions. It changes return values to Result 'Monads' with Success and Failure return containers or Maybe and Nothing containers. This helps us to do kind of railway-oriented-programming when working with mapping. We also use marshmallow , which is the tool we se to describe models and do validation.","title":"General Python info"},{"location":"contributing/#new-environment-tools","text":"Lately we have gotten a few great python environment managers. The first being PyEnv . Pyenv makes working with multiple versions of python easier. The second tool is Poetry . Poetry lets us create a lock file of all our dependencies, this means that both version of python and version of each dependency and its dependencies will be equal for everyone working on the project. It also uses the new pyproject.toml file which is the 'new' setup.py and requirements.txt in 1 file. Poetry also handles building and publishing.","title":"New Environment Tools"},{"location":"contributing/#setup-the-tools","text":"get pyenv - pyenv lets you work with multiple versions of python $ brew update $ brew install pyenv Put this command into the of ~/.bash_profile or run pyenv init to make sure where to put it for for example zsh. $ eval \"$(pyenv init -)\" install a version of python 3.7+: This installs a clean python to pyenvs folders and lets us reference that as a 'base' in our virtualenvs. $ pyenv install 3 .7.4 get poetry - dependency management: $ curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Make poetry create virtualenv in project folder. This makes it easier for IDE's to run correct virtualenv while debuging/running linters etc. $ poetry config settings.virtualenvs.in-project true","title":"Setup the tools"},{"location":"contributing/#setup-dev-environment","text":"activate pyenv for the current shell $ pyenv shell 3 .7.4 This creates a virtualenv and installs all dependencies including dev: $ poetry install Now test that everything works. poetry run, runs a command in the virtualenv $ poetry run pytest initialize pre-commit hooks for git $ poetry run pre-commit install","title":"Setup dev environment"},{"location":"test-swagger/","text":"window.onload = function() { const ui = SwaggerUIBundle({ url: \"https://github.com/greenbird/piri/blob/master/mapmallow/schema.json\", dom_id: '#swagger-ui', presets: [ SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset ] }) window.ui = ui } extra_css : - stylesheets/swagger-ui.css extra_javascript : - javascripts/swagger-ui-bundle.js - javascripts/swagger-ui-standalone-preset.js","title":"Test swagger"},{"location":"usage/","text":"The goal of this library is to make configurable data transformation(mapping) easy and flexible. We have decided to only support json to json mapping. This is because quite frankly its impossible to have configurable mapping that works on any format. We chose json because its quite easy to make anything into json and its quite easy to make json into anything. When we made this library we have dealt primarily with csv data or xml data. example csv file could looks something like this: thomas;borgen;street123;1010;20-10-10;500 john;doe;street124;1011;20-10-11;6000 which would easily be turned in a json file looking like this: { \"data\" : [ [ \"thomas\" , \"borgen\" , \"street123\" , \"1010\" , \"19-10-2020\" , \"500\" ], [ \"john\" , \"doe\" , \"street124\" , \"1011\" , \"20-10-2020\" , \"6000\" ], ] } Lets say we want to map this into a structure like this [ { \"name\" : \"firstname lastname\" , \"address\" : { \"street\" : \"street\" , \"zip\" : \"zipcode\" }, \"invoice\" : { \"due_date\" : \"isodate\" , \"amount\" : 10.0 } } ] Then we'd use a configuration that you will see is structurally quite similar to the output that we want. { \"name\" : \"root\" , \"array\" : true , \"path_to_iterable\" : [ \"data\" ], \"attributes\" : [ { \"name\" : \"name\" , \"mappings\" : [ { \"path\" : [ \"data\" , 0 ] }, { \"path\" : [ \"data\" , 1 ] } ], \"separator\" : \" \" } ], \"objects\" : [ { \"name\" : \"address\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"street\" , \"mappings\" : [ { \"path\" : [ \"data\" , 2 ] } ] }, { \"name\" : \"zip\" , \"mappings\" : [ { \"path\" : [ \"data\" , 3 ] } ] } ] }, { \"name\" : \"invoice\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"due_date\" , \"mappings\" : [ { \"path\" : [ \"data\" , 4 ] } ], \"casting\" : { \"to\" : \"date\" , \"original_format\" : \"dd.mm.yyyy\" } }, { \"name\" : \"amount\" , \"mappings\" : [ { \"path\" : [ \"data\" , 5 ] } ], \"casting\" : { \"to\" : \"decimal\" } } ] } ] } which will produce [ { \"name\" : \"thomas borgen\" , \"address\" : { \"street\" : \"street123\" , \"zip\" : \"1010\" }, \"invoice\" : { \"due_date\" : \"2020-10-20\" , \"amount\" : 500.0 } }, { \"name\" : \"john doe\" , \"address\" : { \"street\" : \"street124\" , \"zip\" : \"1011\" }, \"invoice\" : { \"due_date\" : \"2020-10-19\" , \"amount\" : 6000.0 } } ]","title":"Usage"}]}