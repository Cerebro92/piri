{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Piri \u00b6 Configurable Data Mapping for mortals Documentation | Source Code | Task Tracker What is Piri \u00b6 Piri is a JSON to JSON mapper. That means that we read input JSON and create output JSON. How the output is created is based on instructions from a configuration file. The configuration file governs the the output structure and tells piri where in the input to find data and where to place it in the output. In addition to this Piri supports data transformation with data casting , if conditions , combination of data from multiple places and of course setting default values. This enables you to change any input into the output you desire. Typical usecases \u00b6 You GET data form api, but need to transform it for your backend system POST ing data to an api that needs data on a different format than what your system produces All your backends speak different language? pipe it through Piri Customer delivers weirdly formatted data? Use Piri to make it sexy Have CSV but need nicely structured JSON? make CSV into a JSON list and transform it with Piri Have XML but need to change it? make it into JSON, transform it with Piri and then dump it to XML again. Customers legacy system needs CSV. Use Piri to transform your nicely structured JSON data into a JSON List that can be easily dumped to CSV Official Open Piri Solutions \u00b6 piri-cli , commandline interface for file to file mapping. piri-web , One Click deploy Web REST API for Piri JSON mapping. Enterprise solutions \u00b6 Coming... Goal \u00b6 The goal of this library is to make JSON to JSON transformation/mapping easy, configurable and documentable. We achieve this by using a simple but feature-rich JSON configuration which then also acts as documentation and as a contract between parties. Why \u00b6 Piri was born because we really dislike mapping. Documenting whatever decisions made in your code so that some product owner understands it is also no me gusto . Transforming data from one format to another is something software engineers do allmost daily... It should be easy! And documenting it shouldn't be something you have to worry about. After the Worst POC in History we never wanted to do mapping by scripts and code again. This lead to the idea that it should be possible to create a file which governs how the structure should look and how the data should be transformed. This would then be the single source of truth and with Piri we have achieved this. We believe that this will make collaboration between teams faster and easier. Use Piri to agree with data formats between Front-end and Back-end. Between the 3rd party system and your back-end. You can even use Piri for testing existing integrations ;-) Features \u00b6 Mapping with configuration File. JSON Schema validation of the config file. Structurally Transform JSON Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date Contributing \u00b6 Please see contribute Installation \u00b6 Package is on pypi. Use pip or poetry to install pip install piri poetry add piri Quickstart \u00b6 import simplejson from piri.process import process my_config = { 'name' : 'schema' , 'array' : False , 'objects' : [ { 'name' : 'invoices' , 'array' : True , 'path_to_iterable' : [ 'root' , 'invoices' ], 'attributes' : [ { 'name' : 'amount' , 'mappings' : [ { 'path' : [ 'invoices' , 'amount' ], }, ], 'casting' : { 'to' : 'decimal' , 'original_format' : 'integer_containing_decimals' , }, 'default' : 0 , }, { 'name' : 'debtor' , 'mappings' : [ { 'path' : [ 'root' , 'customer' , 'first_name' ], }, { 'path' : [ 'root' , 'customer' , 'last_name' ], }, ], 'separator' : ' ' , }, ], 'objects' : [], }, ], } example_data = { 'root' : { 'customer' : { 'first_name' : 'John' , 'last_name' : 'Smith' , }, 'invoices' : [ { 'amount' : 10050 , }, { 'amount' : 20050 , }, { 'amount' : - 15005 , }, ], }, } mapped_data = process ( example_data , my_config ) with open ( 'resultfile.json' , 'w' ) as output_file : output_file . write ( simplejson . dumps ( mapped_data )) contents of resultfile.json { \"invoices\" : [ { \"amount\" : 100.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : 200.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : -150.05 , \"debtor\" : \"John Smith\" } ] }","title":"Home"},{"location":"#piri","text":"Configurable Data Mapping for mortals Documentation | Source Code | Task Tracker","title":"Piri"},{"location":"#what-is-piri","text":"Piri is a JSON to JSON mapper. That means that we read input JSON and create output JSON. How the output is created is based on instructions from a configuration file. The configuration file governs the the output structure and tells piri where in the input to find data and where to place it in the output. In addition to this Piri supports data transformation with data casting , if conditions , combination of data from multiple places and of course setting default values. This enables you to change any input into the output you desire.","title":"What is Piri"},{"location":"#typical-usecases","text":"You GET data form api, but need to transform it for your backend system POST ing data to an api that needs data on a different format than what your system produces All your backends speak different language? pipe it through Piri Customer delivers weirdly formatted data? Use Piri to make it sexy Have CSV but need nicely structured JSON? make CSV into a JSON list and transform it with Piri Have XML but need to change it? make it into JSON, transform it with Piri and then dump it to XML again. Customers legacy system needs CSV. Use Piri to transform your nicely structured JSON data into a JSON List that can be easily dumped to CSV","title":"Typical usecases"},{"location":"#official-open-piri-solutions","text":"piri-cli , commandline interface for file to file mapping. piri-web , One Click deploy Web REST API for Piri JSON mapping.","title":"Official Open Piri Solutions"},{"location":"#enterprise-solutions","text":"Coming...","title":"Enterprise solutions"},{"location":"#goal","text":"The goal of this library is to make JSON to JSON transformation/mapping easy, configurable and documentable. We achieve this by using a simple but feature-rich JSON configuration which then also acts as documentation and as a contract between parties.","title":"Goal"},{"location":"#why","text":"Piri was born because we really dislike mapping. Documenting whatever decisions made in your code so that some product owner understands it is also no me gusto . Transforming data from one format to another is something software engineers do allmost daily... It should be easy! And documenting it shouldn't be something you have to worry about. After the Worst POC in History we never wanted to do mapping by scripts and code again. This lead to the idea that it should be possible to create a file which governs how the structure should look and how the data should be transformed. This would then be the single source of truth and with Piri we have achieved this. We believe that this will make collaboration between teams faster and easier. Use Piri to agree with data formats between Front-end and Back-end. Between the 3rd party system and your back-end. You can even use Piri for testing existing integrations ;-)","title":"Why"},{"location":"#features","text":"Mapping with configuration File. JSON Schema validation of the config file. Structurally Transform JSON Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date","title":"Features"},{"location":"#contributing","text":"Please see contribute","title":"Contributing"},{"location":"#installation","text":"Package is on pypi. Use pip or poetry to install pip install piri poetry add piri","title":"Installation"},{"location":"#quickstart","text":"import simplejson from piri.process import process my_config = { 'name' : 'schema' , 'array' : False , 'objects' : [ { 'name' : 'invoices' , 'array' : True , 'path_to_iterable' : [ 'root' , 'invoices' ], 'attributes' : [ { 'name' : 'amount' , 'mappings' : [ { 'path' : [ 'invoices' , 'amount' ], }, ], 'casting' : { 'to' : 'decimal' , 'original_format' : 'integer_containing_decimals' , }, 'default' : 0 , }, { 'name' : 'debtor' , 'mappings' : [ { 'path' : [ 'root' , 'customer' , 'first_name' ], }, { 'path' : [ 'root' , 'customer' , 'last_name' ], }, ], 'separator' : ' ' , }, ], 'objects' : [], }, ], } example_data = { 'root' : { 'customer' : { 'first_name' : 'John' , 'last_name' : 'Smith' , }, 'invoices' : [ { 'amount' : 10050 , }, { 'amount' : 20050 , }, { 'amount' : - 15005 , }, ], }, } mapped_data = process ( example_data , my_config ) with open ( 'resultfile.json' , 'w' ) as output_file : output_file . write ( simplejson . dumps ( mapped_data )) contents of resultfile.json { \"invoices\" : [ { \"amount\" : 100.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : 200.5 , \"debtor\" : \"John Smith\" }, { \"amount\" : -150.05 , \"debtor\" : \"John Smith\" } ] }","title":"Quickstart"},{"location":"changelog/","text":"Version history \u00b6 Change Bumps Breaking major New Feature minor otherwise patch Patch 1.0.2 - Bugfix \u00b6 Loading schema.json used relatve path that did not work when package was imported by other package. Now we use '{0}/schema.json'.format(os.path.dirname(__file__)) to get absolute path to our schema.json. Patch 1.0.1 \u00b6 adds python versions badge removes bad part of documentation Version 1.0.0 Release: Piri Reis \u00b6 The first release focuses on key mapping functionality. Finding values from multiple places and combining them to one. Setting default values, Casting values, and applying if statements. This should suffice for a lot of usecases where one need to transform json into structurally different json. Features \u00b6 Mapping with configuration File. Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date","title":"Changelog"},{"location":"changelog/#version-history","text":"Change Bumps Breaking major New Feature minor otherwise patch","title":"Version history"},{"location":"changelog/#patch-102-bugfix","text":"Loading schema.json used relatve path that did not work when package was imported by other package. Now we use '{0}/schema.json'.format(os.path.dirname(__file__)) to get absolute path to our schema.json.","title":"Patch 1.0.2 - Bugfix"},{"location":"changelog/#patch-101","text":"adds python versions badge removes bad part of documentation","title":"Patch 1.0.1"},{"location":"changelog/#version-100-release-piri-reis","text":"The first release focuses on key mapping functionality. Finding values from multiple places and combining them to one. Setting default values, Casting values, and applying if statements. This should suffice for a lot of usecases where one need to transform json into structurally different json.","title":"Version 1.0.0 Release: Piri Reis"},{"location":"changelog/#features","text":"Mapping with configuration File. Combine multiple values to one. Default values If statements is, contains, not casting integer, decimal, iso date","title":"Features"},{"location":"configuration/","text":"Configuration Json data \u00b6 The configuration governs not only where to find data, but also the structure of the output which will mirror the structure in the configuration json. The two main components of the configuration json is the object and attributes. An object can contain nested objects and/or attributes. In the attribute part of the file is where you actually tell the mapper where to find data. In the object you are deciding the structure and also telling the mapper if there are iterable data anywhere that needs to be iterated to create multiple instances. Object \u00b6 An object has a name, it can have attributes, nested objects or a special type of objects called branching objects . It will also know if itself is an array and the path to where the input data can be iterated to create multiple objects. name type description comment name str name of the key it will get in parent object the root will not get a name array bool tells the mapper if this should be an array or not path_to_iterable array[str|int] path to itrable data where this and child parts of the configuration should be applied per iteration attributes array[ attribute ] An array of this objects attribute mappings objects array[ object ] Here you can nest more objects. branching_objects array[ branching object ] Array of a special kind of object rarely used { \"name\" : \"object_name\" , \"array\" : true , \"path_to_iterable\" : [ \"path\" , \"to\" , \"list\" ], \"objects\" : [], \"branching_objects\" : [], \"attributes\" : [] } Attribute \u00b6 The attributes are like 'color' of a car or 'amount' in an invoice. Attributes are have a name ('amount'), a number of mappings, separator, if statements, casting and a default value if all else fails. name type description default name str The name it will get in the parent object mappings array[ mapping ] list of mapping objects which is where to find data [] separator str string to separate each value in case multiple are found in mapping step '' if_statements array[ if statement ] If statements that can change data based on conditions [] casting casting Lets you cast data to a spesific type [int, decimal, date] {} default Any If after all mapping, if statements and casting the result is None this value is used None { \"name\" : \"attribute_name\" , \"mappings\" : [], \"separator\" : \"\" , \"if_statements\" : [], \"casting\" : {}, \"default\" : \"default value\" } Mapping \u00b6 This is the only place where actual interaction with the input data is done. name type description default path array[str|int] path to data you want to retrieve. [] if_statements array[ if statement ] If statements that can change data based on conditions [] default Any If no value is found or value is None after if_statements then this value is used None Note either path or default must contain a something Explanation of path You add a list of strings or integers that will get you to your data. so for example if you needed to get to the second element in the list called my_list in the following json then your path will be [\"my_list\", 1] and you will get the value index1 { \"my_list\" : [ \"index0\" , \"index1\" ] } if_statements: list of if statements that can change the data depending on conditions default: a default value if none is found or value found is None { \"path\" : [ \"path\" , \"to\" , \"data\" ], \"if_statements\" : [], \"default\" : \"default\" } input({'path': { 'to': { 'data': 'value'}}}) -> 'value' input({'path': { 'does_not_exist'}}) -> 'default' input() -> 'default' If Statement \u00b6 This is where you can change found(or not found) data to something else based on a condition. They are chained in the sense that what the first one produces will be the input to the next one. Thus if you want the original value if the first one fails, then leave out otherwise name type description default condition \"is\"|\"not\"|\"contains\" What condition to use when checking value against target target str|number|bool Target what we do our condition against ie: value == target when condition is is then str|number|bool value that we will return if the condition is true otherwise str|number|bool Optional value that we can return if the condition is false None { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"first_type\" , \"otherwise\" : \"default_type\" } input('2') -> 'default_type' input('1') -> 'first_type' Casting object \u00b6 The casting object lets you cast whatever value is found to some new value. Currently integer, decimal and date are supported and original format is optional helper data that we need for some special cases where the format of the input value cannot be asserted automatically. name type description default to one of [\"integer\", \"decimal\", \"date\"] What type to cast the value to original_format \"integer_containing_decimals\" or spesific date format(see below)\" For some values we need to specify extra information in order to correctly cast it. None about original format Note When to is date then original_format is required . when to is original format description decimal integer_containing_decimals is used when some integer value should be casted to decimal and we need to divide it by 100 date yyyy.mm.dd yy.mm.dd yymmdd dd.mm.yyyy dd.mm.yy ddmmyy The format of the input date. . means any delimiter. Output is always iso-date yyyy-mm-dd Examples { \"to\" : \"decimal\" , \"original_format\" : \"integer_containing_decimals\" } \"10050\" -> Decimal(100.50) { \"to\" : \"date\" , \"original_format\" : \"ddmmyyyy\" } \"01012001\" -> \"2010-01-01\" Branching Object \u00b6 The branching object is a special object that does not have attributes or object childs but has a special branching_attributes child. The point of this object is to make sure that we can map data from different sources into the same element. for example, we have an object called \"extradata\" with the attributes 'name' and 'data'. This is kind of a field that can be many things. like 'name' = 'extra_address_line1', and another one with 'extra_address_line2'. This must then get its data from different places, and thats what these branching objects are for. name type description default name str Name of the object array bool if it should be an array or not path_to_iterable array[str, int] path to list [] branching_attributes array[array[ attribute ]] list of list of attributes where each list of attributes will create a branching object. Example { \"name\" : \"extradata\" , \"array\" : true , \"branching_attributes\" : [ [ { \"name\" : \"name\" , \"default\" : \"extra_address_line1\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line1\" , \"value\" ]}] } ], [ { \"name\" : \"name\" , \"default\" : \"extra_address_line2\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line2\" , \"value\" ]}] } ] ] } This will produce: { \"extradata\" : [ { \"name\" : \"extra_address_line1\" , \"data\" : \"address value 1\" }, { \"name\" : \"extra_address_line2\" , \"data\" : \"address value 2\" } ] }","title":"Configuration"},{"location":"configuration/#configuration-json-data","text":"The configuration governs not only where to find data, but also the structure of the output which will mirror the structure in the configuration json. The two main components of the configuration json is the object and attributes. An object can contain nested objects and/or attributes. In the attribute part of the file is where you actually tell the mapper where to find data. In the object you are deciding the structure and also telling the mapper if there are iterable data anywhere that needs to be iterated to create multiple instances.","title":"Configuration Json data"},{"location":"configuration/#object","text":"An object has a name, it can have attributes, nested objects or a special type of objects called branching objects . It will also know if itself is an array and the path to where the input data can be iterated to create multiple objects. name type description comment name str name of the key it will get in parent object the root will not get a name array bool tells the mapper if this should be an array or not path_to_iterable array[str|int] path to itrable data where this and child parts of the configuration should be applied per iteration attributes array[ attribute ] An array of this objects attribute mappings objects array[ object ] Here you can nest more objects. branching_objects array[ branching object ] Array of a special kind of object rarely used { \"name\" : \"object_name\" , \"array\" : true , \"path_to_iterable\" : [ \"path\" , \"to\" , \"list\" ], \"objects\" : [], \"branching_objects\" : [], \"attributes\" : [] }","title":"Object"},{"location":"configuration/#attribute","text":"The attributes are like 'color' of a car or 'amount' in an invoice. Attributes are have a name ('amount'), a number of mappings, separator, if statements, casting and a default value if all else fails. name type description default name str The name it will get in the parent object mappings array[ mapping ] list of mapping objects which is where to find data [] separator str string to separate each value in case multiple are found in mapping step '' if_statements array[ if statement ] If statements that can change data based on conditions [] casting casting Lets you cast data to a spesific type [int, decimal, date] {} default Any If after all mapping, if statements and casting the result is None this value is used None { \"name\" : \"attribute_name\" , \"mappings\" : [], \"separator\" : \"\" , \"if_statements\" : [], \"casting\" : {}, \"default\" : \"default value\" }","title":"Attribute"},{"location":"configuration/#mapping","text":"This is the only place where actual interaction with the input data is done. name type description default path array[str|int] path to data you want to retrieve. [] if_statements array[ if statement ] If statements that can change data based on conditions [] default Any If no value is found or value is None after if_statements then this value is used None Note either path or default must contain a something Explanation of path You add a list of strings or integers that will get you to your data. so for example if you needed to get to the second element in the list called my_list in the following json then your path will be [\"my_list\", 1] and you will get the value index1 { \"my_list\" : [ \"index0\" , \"index1\" ] } if_statements: list of if statements that can change the data depending on conditions default: a default value if none is found or value found is None { \"path\" : [ \"path\" , \"to\" , \"data\" ], \"if_statements\" : [], \"default\" : \"default\" } input({'path': { 'to': { 'data': 'value'}}}) -> 'value' input({'path': { 'does_not_exist'}}) -> 'default' input() -> 'default'","title":"Mapping"},{"location":"configuration/#if-statement","text":"This is where you can change found(or not found) data to something else based on a condition. They are chained in the sense that what the first one produces will be the input to the next one. Thus if you want the original value if the first one fails, then leave out otherwise name type description default condition \"is\"|\"not\"|\"contains\" What condition to use when checking value against target target str|number|bool Target what we do our condition against ie: value == target when condition is is then str|number|bool value that we will return if the condition is true otherwise str|number|bool Optional value that we can return if the condition is false None { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"first_type\" , \"otherwise\" : \"default_type\" } input('2') -> 'default_type' input('1') -> 'first_type'","title":"If Statement"},{"location":"configuration/#casting-object","text":"The casting object lets you cast whatever value is found to some new value. Currently integer, decimal and date are supported and original format is optional helper data that we need for some special cases where the format of the input value cannot be asserted automatically. name type description default to one of [\"integer\", \"decimal\", \"date\"] What type to cast the value to original_format \"integer_containing_decimals\" or spesific date format(see below)\" For some values we need to specify extra information in order to correctly cast it. None about original format Note When to is date then original_format is required . when to is original format description decimal integer_containing_decimals is used when some integer value should be casted to decimal and we need to divide it by 100 date yyyy.mm.dd yy.mm.dd yymmdd dd.mm.yyyy dd.mm.yy ddmmyy The format of the input date. . means any delimiter. Output is always iso-date yyyy-mm-dd Examples { \"to\" : \"decimal\" , \"original_format\" : \"integer_containing_decimals\" } \"10050\" -> Decimal(100.50) { \"to\" : \"date\" , \"original_format\" : \"ddmmyyyy\" } \"01012001\" -> \"2010-01-01\"","title":"Casting object"},{"location":"configuration/#branching-object","text":"The branching object is a special object that does not have attributes or object childs but has a special branching_attributes child. The point of this object is to make sure that we can map data from different sources into the same element. for example, we have an object called \"extradata\" with the attributes 'name' and 'data'. This is kind of a field that can be many things. like 'name' = 'extra_address_line1', and another one with 'extra_address_line2'. This must then get its data from different places, and thats what these branching objects are for. name type description default name str Name of the object array bool if it should be an array or not path_to_iterable array[str, int] path to list [] branching_attributes array[array[ attribute ]] list of list of attributes where each list of attributes will create a branching object. Example { \"name\" : \"extradata\" , \"array\" : true , \"branching_attributes\" : [ [ { \"name\" : \"name\" , \"default\" : \"extra_address_line1\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line1\" , \"value\" ]}] } ], [ { \"name\" : \"name\" , \"default\" : \"extra_address_line2\" }, { \"name\" : \"data\" , \"mappings\" : [{ \"path\" : [ \"list\" , \"to\" , \"line2\" , \"value\" ]}] } ] ] } This will produce: { \"extradata\" : [ { \"name\" : \"extra_address_line1\" , \"data\" : \"address value 1\" }, { \"name\" : \"extra_address_line2\" , \"data\" : \"address value 2\" } ] }","title":"Branching Object"},{"location":"contributing/","text":"Contributing \u00b6 General Python info \u00b6 In this package we make extensive use of the Returns library . Its a library that forces us to try and write None free code and also wraps exceptions. It changes return values to Result 'Monads' with Success and Failure return containers or Maybe and Nothing containers. This helps us to do kind of railway-oriented-programming when working with mapping. We also use marshmallow , which is the tool we use to describe models and do validation. New Environment Tools \u00b6 Lately we have gotten a few great python environment managers. The first being PyEnv . Pyenv makes working with multiple versions of python easier. The second tool is Poetry . Poetry lets us create a lock file of all our dependencies, this means that both version of python and version of each dependency and its dependencies will be equal for everyone working on the project. It also uses the new pyproject.toml file which is the 'new' setup.py and requirements.txt in 1 file. Poetry also handles building and publishing. Setup the tools \u00b6 get pyenv - pyenv lets you work with multiple versions of python $ brew update $ brew install pyenv Put this command into the of ~/.bash_profile or run pyenv init to make sure where to put it for for example zsh. $ eval \"$(pyenv init -)\" install a version of python 3.7+: This installs a clean python to pyenvs folders and lets us reference that as a 'base' in our virtualenvs. $ pyenv install 3 .7.4 get poetry - dependency management: $ curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Make poetry create virtualenv in project folder. This makes it easier for IDE's to run correct virtualenv while debuging/running linters etc. $ poetry config settings.virtualenvs.in-project true Setup dev environment \u00b6 activate pyenv for the current shell $ pyenv shell 3 .7.4 This creates a virtualenv and installs all dependencies including dev: $ poetry install Now test that everything works. poetry run, runs a command in the virtualenv $ poetry run pytest initialize pre-commit hooks for git $ poetry run pre-commit install","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#general-python-info","text":"In this package we make extensive use of the Returns library . Its a library that forces us to try and write None free code and also wraps exceptions. It changes return values to Result 'Monads' with Success and Failure return containers or Maybe and Nothing containers. This helps us to do kind of railway-oriented-programming when working with mapping. We also use marshmallow , which is the tool we use to describe models and do validation.","title":"General Python info"},{"location":"contributing/#new-environment-tools","text":"Lately we have gotten a few great python environment managers. The first being PyEnv . Pyenv makes working with multiple versions of python easier. The second tool is Poetry . Poetry lets us create a lock file of all our dependencies, this means that both version of python and version of each dependency and its dependencies will be equal for everyone working on the project. It also uses the new pyproject.toml file which is the 'new' setup.py and requirements.txt in 1 file. Poetry also handles building and publishing.","title":"New Environment Tools"},{"location":"contributing/#setup-the-tools","text":"get pyenv - pyenv lets you work with multiple versions of python $ brew update $ brew install pyenv Put this command into the of ~/.bash_profile or run pyenv init to make sure where to put it for for example zsh. $ eval \"$(pyenv init -)\" install a version of python 3.7+: This installs a clean python to pyenvs folders and lets us reference that as a 'base' in our virtualenvs. $ pyenv install 3 .7.4 get poetry - dependency management: $ curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Make poetry create virtualenv in project folder. This makes it easier for IDE's to run correct virtualenv while debuging/running linters etc. $ poetry config settings.virtualenvs.in-project true","title":"Setup the tools"},{"location":"contributing/#setup-dev-environment","text":"activate pyenv for the current shell $ pyenv shell 3 .7.4 This creates a virtualenv and installs all dependencies including dev: $ poetry install Now test that everything works. poetry run, runs a command in the virtualenv $ poetry run pytest initialize pre-commit hooks for git $ poetry run pre-commit install","title":"Setup dev environment"},{"location":"introduction/","text":"Piri uses a configuration file to govern output structure and contents. This section is the introductionary course to Piri. The setup \u00b6 For this introduction course we will use piri-cli since it provides you with a simple command line tool to run piri. And no need to create any python files. Install with pip: pip install piri-cli All examples will have a config, input and output json tab like this: config.json {} input.json {} output.json {} Copy the contents of config.json and input.json down to your working dir. Run all examples with the following unless otherwise stated. piri config.json input.json About JSON \u00b6 Json is a human readable data format that stores data in objects consisting of attribute-value pairs and arrays. We will use the terms object and attribute quite often in this guide. To put it simply an object contains attributes that hold values . These values can sometimes be another object or even an array of objects. { \"person\" : { \"name\" : \"Bob\" , \"height\" : 180.5 , \"friends\" : [ { \"name\" : \"John\" , \"height\" : 170.5 } ] } } person is an object , name and height are attribtes , \"Bob\" and 180.5 are values to those attributes. friends is a list(array) of objects. The Root \u00b6 The root of all ev... piri configs looks like this { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [], \"objects\" : [] } So this will fail since we consider empty result a failure, but this config generates the enclosing {} brackets you can see in the example in the About JSON section. {} Adding Attributes to root \u00b6 To actually map some data we can add attributes . config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"default\" : \"Thomas\" } ] } input.json {} output.json { \"firstname\" : \"Thomas\" } Congratulations, you've just mapped a default value to an attribute! Structuring with objects \u00b6 config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"person\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"default\" : \"Thomas\" } ] } ] } input.json {} output.json { \"person\" : { \"firstname\" : \"Thomas\" } } What we just did is the core principle of creating the output structure. We added an object with the name person , then we moved our firstname attribute to the person object. Time to Map some values! \u00b6 We will now introduce the mappings key, it's and array of mapping objects. The mapping object is the only place where you actually fetch data from the input. And you do that by specifying a path . The path describes the steps to take to get to the value we are interested in. Mapping.path with flat structure \u00b6 config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"person\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"mappings\" : [ { \"path\" : [ \"name\" ] } ] } ] } ] } input.json { \"name\" : \"Neo\" } output.json { \"person\" : { \"firstname\" : \"Neo\" } } Mapping.path with nested structure \u00b6 config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"actor\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"name\" , \"mappings\" : [ { \"path\" : [ \"the_matrix\" , \"neo\" , \"actor\" , \"name\" ] } ] } ] } ] } input.json { \"the_matrix\" : { \"neo\" : { \"actor\" : { \"name\" : \"Keanu Reeves\" } } } } output.json { \"actor\" : { \"name\" : \"Keanu Reeves\" } } Mapping.path with data in lists \u00b6 Consider the following json: { \"data\" : [ \"Keanu\" , \"Reeves\" , \"The Matrix\" ] } In our mapping object we supply path which is a list of how we get to our data. So how do we get the lastname in that data? Easy, we reference the index of the list. The first data in the list starts at 0 , second element 1 , third 2 and so on. This number is the index and to get the last name we must use the index: 1 config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"mappings\" : [ { \"path\" : [ \"data\" , 0 ] } ] }, { \"name\" : \"lastname\" , \"mappings\" : [ { \"path\" : [ \"data\" , 1 ] } ] } ] } input.json { \"data\" : [ \"Keanu\" , \"Reeves\" , \"The Matrix\" ] } output.json { \"firstname\" : \"Keanu\" , \"lastname\" : \"Reeves\" } Note We still have to reference the \"data\" key first, so our path goes first to data then it finds the value at index 1 Combining values \u00b6 Now lets learn how to combine values from multiple places in the input. It's fairly normal to only need name but getting firstname and lastname in input data. Lets combine them! config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"actor\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"name\" , \"mappings\" : [ { \"path\" : [ \"the_matrix\" , \"neo\" , \"actor\" , \"firstname\" ] }, { \"path\" : [ \"the_matrix\" , \"neo\" , \"actor\" , \"lastname\" ] } ], \"separator\" : \" \" , } ] } ] } input.json { \"the_matrix\" : { \"neo\" : { \"actor\" : { \"firstname\" : \"Keanu\" , \"lastname\" : \"Reeves\" } } } } output.json { \"actor\" : { \"name\" : \"Keanu Reeves\" } } To find more values and combine them, simply add another mapping object to mappings array. Use separator to control with what char values should be separated. If statements \u00b6 Are useful for when you for example get some numbers in your data that are supposed to represent different types. Simple if statement \u00b6 Let's check if the value equals 1 and output type_one . config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"readable_type\" , \"mappings\" : [ { \"path\" : [ \"type\" ], \"if_statements\" : [ { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"type_one\" } ] } ] } ] } input.json { \"type\" : \"1\" } output.json { \"readable_type\" : \"type_one\" } If statements are really useful for changing the values depending on some condition. Check the list of supported conditions. otherwise can also be used to specify should happen if the condition is false . If otherwise is not provided then output will be the original value. Chain If Statements \u00b6 if_statements is a list of if statement objects. We designed it like this so that we can chain them. The output of the first one will be the input of the next one. the mapping object is not the only one that can have if statements, the attribute can also have them. This allows for some interesting combinations. config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"readable_type\" , \"mappings\" : [ { \"path\" : [ \"type\" ], \"if_statements\" : [ { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"boring-type\" }, { \"condition\" : \"is\" , \"target\" : \"2\" , \"then\" : \"boring-type-two\" , \"otherwise\" : \"fun-type\" }, { \"condition\" : \"contains\" , \"target\" : \"fun\" , \"then\" : \"funky_type\" } ] } ], \"if_statements\" : [ { \"condition\" : \"not\" , \"target\" : \"funky_type\" , \"then\" : \"junk\" , \"otherwise\" : \"funk\" } ] } ] } input.json { \"type\" : \"1\" } output.json { \"readable_type\" : \"funk\" } input2.json { \"type\" : \"2\" } output2.json { \"readable_type\" : \"junk\" } Using input.json the places that are highlighted is everywhere the value changes. For input2.json the first if statement is false and no value change. The second if statement is true so value is changed to boring-type-two . The third if statement is false so no value change. The last if statement checks if the value is not funky_type which is true, so the value is changed to junk . You can even add if statements for every mapping object you add into mappings so this can handle some quite complicated condition with multiple values. Casting values \u00b6 You've learned how to structure your output with objects, find values and asigning them to attributes, combining values and applying if statements. Its now time to learn how to cast values. Casting values is very useful for when we get string(text) data that should be numbers. Or when you get badly(non-iso) formatted date values that you want to change to ISO dates Casting is straightforward. You map your value like you would and then add the casting object. Casting to decimal \u00b6 config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"my_number\" , \"mappings\" : [ { \"path\" : [ \"string_number\" ] } ], \"casting\" : { \"to\" : \"decimal\" } } ] } input.json { \"string_number\" : \"123.12\" } output.json { \"my_number\" : 123.12 } Casting to ISO Date \u00b6 When casting to a date we always have to supply the original_format which is the format that the input data is on. without knowing this there would be know way to know fore sure in every case if it was dd.mm.yy or yy.mm.dd config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"my_iso_date\" , \"mappings\" : [ { \"path\" : [ \"yymmdd_date\" ] } ], \"casting\" : { \"to\" : \"date\" , \"original_format\" : \"yymmdd\" } } ] } input.json { \"yymmdd_date\" : \"101020\" } output.json { \"my_iso_date\" : \"2010-10-20\" } Check our the configuration docs on casting for more info Working with lists \u00b6 Finally! Last topic and the most interesting one! Usually the data that you are processing is not one thing, but a list of things(data). We want to iterate the list and for each and every piece of data in that list we want to transform it. This is the section that lets you do that. Lets say we are creating a website for an RPG game that dumps its data in a flat format. Every line is a player with a name , class , money , and x , y coordinates for where he is in the world. data.json { \"data\" : { \"something_uninteresting\" : [ 1 , 2 , 3 ], \"character_data\" : [ [ \"SuperAwesomeNick\" , 1 , 500 ], [ \"OtherAwesomeDude\" , 2 , 300 ], [ \"PoorDude\" , 2 , 10 ] ] } } Now to make the frontend dudes happy we would liketo structure this nicely... something like: { \"players\" : [ { \"nickname\" : \"SuperAwesomeNick\" , \"class\" : \"warrior\" , \"gold\" : 500 , }, { \"nickname\" : \"OtherAwesomeDude\" , ... } ] } Introducing Path to Iterable \u00b6 We can use path_to_iterable on an object which works similar to mapping.path , but it applies the current object and all its attrbute mappings and nested objects to each and every element in whatever list path_to_iterable points to. Lets solve the above example! config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"players\" , \"array\" : true , \"path_to_iterable\" : [ \"data\" , \"character_data\" ], \"attributes\" : [ { \"name\" : \"nickname\" , \"mappings\" : [ { \"path\" : [ \"character_data\" , 0 ] } ] }, { \"name\" : \"class\" , \"mappings\" : [ { \"path\" : [ \"character_data\" , 1 ] } ], \"if_statements\" : [ { \"condition\" : \"is\" , \"target\" : 1 , \"then\" : \"warrior\" , \"otherwise\" : \"cleric\" } ] }, { \"name\" : \"gold\" , \"mappings\" : [ { \"path\" : [ \"character_data\" , 2 ] } ] } ] } ] } input.json { \"data\" : { \"something_uninteresting\" : [ 1 , 2 , 3 ], \"character_data\" : [ [ \"SuperAwesomeNick\" , 1 , 500 ], [ \"OtherAwesomeDude\" , 2 , 300 ], [ \"PoorDude\" , 2 , 10 ] ] } } output.json { \"players\" : [ { \"nickname\" : \"SuperAwesomeNick\" , \"class\" : \"warrior\" , \"gold\" : 500 }, { \"nickname\" : \"OtherAwesomeDude\" , \"class\" : \"cleric\" , \"gold\" : 300 }, { \"nickname\" : \"PoorDude\" , \"class\" : \"cleric\" , \"gold\" : 10 } ] } Note that we still have to reference the key when mapping. The key name( character_data ) is the last name in the list of path_to_iterable . And thats it! Congratulations the introduction course is done! Time to map some data and have fun doing it!","title":"Introduction"},{"location":"introduction/#the-setup","text":"For this introduction course we will use piri-cli since it provides you with a simple command line tool to run piri. And no need to create any python files. Install with pip: pip install piri-cli All examples will have a config, input and output json tab like this: config.json {} input.json {} output.json {} Copy the contents of config.json and input.json down to your working dir. Run all examples with the following unless otherwise stated. piri config.json input.json","title":"The setup"},{"location":"introduction/#about-json","text":"Json is a human readable data format that stores data in objects consisting of attribute-value pairs and arrays. We will use the terms object and attribute quite often in this guide. To put it simply an object contains attributes that hold values . These values can sometimes be another object or even an array of objects. { \"person\" : { \"name\" : \"Bob\" , \"height\" : 180.5 , \"friends\" : [ { \"name\" : \"John\" , \"height\" : 170.5 } ] } } person is an object , name and height are attribtes , \"Bob\" and 180.5 are values to those attributes. friends is a list(array) of objects.","title":"About JSON"},{"location":"introduction/#the-root","text":"The root of all ev... piri configs looks like this { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [], \"objects\" : [] } So this will fail since we consider empty result a failure, but this config generates the enclosing {} brackets you can see in the example in the About JSON section. {}","title":"The Root"},{"location":"introduction/#adding-attributes-to-root","text":"To actually map some data we can add attributes . config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"default\" : \"Thomas\" } ] } input.json {} output.json { \"firstname\" : \"Thomas\" } Congratulations, you've just mapped a default value to an attribute!","title":"Adding Attributes to root"},{"location":"introduction/#structuring-with-objects","text":"config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"person\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"default\" : \"Thomas\" } ] } ] } input.json {} output.json { \"person\" : { \"firstname\" : \"Thomas\" } } What we just did is the core principle of creating the output structure. We added an object with the name person , then we moved our firstname attribute to the person object.","title":"Structuring with objects"},{"location":"introduction/#time-to-map-some-values","text":"We will now introduce the mappings key, it's and array of mapping objects. The mapping object is the only place where you actually fetch data from the input. And you do that by specifying a path . The path describes the steps to take to get to the value we are interested in.","title":"Time to Map some values!"},{"location":"introduction/#mappingpath-with-flat-structure","text":"config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"person\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"mappings\" : [ { \"path\" : [ \"name\" ] } ] } ] } ] } input.json { \"name\" : \"Neo\" } output.json { \"person\" : { \"firstname\" : \"Neo\" } }","title":"Mapping.path with flat structure"},{"location":"introduction/#mappingpath-with-nested-structure","text":"config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"actor\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"name\" , \"mappings\" : [ { \"path\" : [ \"the_matrix\" , \"neo\" , \"actor\" , \"name\" ] } ] } ] } ] } input.json { \"the_matrix\" : { \"neo\" : { \"actor\" : { \"name\" : \"Keanu Reeves\" } } } } output.json { \"actor\" : { \"name\" : \"Keanu Reeves\" } }","title":"Mapping.path with nested structure"},{"location":"introduction/#mappingpath-with-data-in-lists","text":"Consider the following json: { \"data\" : [ \"Keanu\" , \"Reeves\" , \"The Matrix\" ] } In our mapping object we supply path which is a list of how we get to our data. So how do we get the lastname in that data? Easy, we reference the index of the list. The first data in the list starts at 0 , second element 1 , third 2 and so on. This number is the index and to get the last name we must use the index: 1 config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"firstname\" , \"mappings\" : [ { \"path\" : [ \"data\" , 0 ] } ] }, { \"name\" : \"lastname\" , \"mappings\" : [ { \"path\" : [ \"data\" , 1 ] } ] } ] } input.json { \"data\" : [ \"Keanu\" , \"Reeves\" , \"The Matrix\" ] } output.json { \"firstname\" : \"Keanu\" , \"lastname\" : \"Reeves\" } Note We still have to reference the \"data\" key first, so our path goes first to data then it finds the value at index 1","title":"Mapping.path with data in lists"},{"location":"introduction/#combining-values","text":"Now lets learn how to combine values from multiple places in the input. It's fairly normal to only need name but getting firstname and lastname in input data. Lets combine them! config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"actor\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"name\" , \"mappings\" : [ { \"path\" : [ \"the_matrix\" , \"neo\" , \"actor\" , \"firstname\" ] }, { \"path\" : [ \"the_matrix\" , \"neo\" , \"actor\" , \"lastname\" ] } ], \"separator\" : \" \" , } ] } ] } input.json { \"the_matrix\" : { \"neo\" : { \"actor\" : { \"firstname\" : \"Keanu\" , \"lastname\" : \"Reeves\" } } } } output.json { \"actor\" : { \"name\" : \"Keanu Reeves\" } } To find more values and combine them, simply add another mapping object to mappings array. Use separator to control with what char values should be separated.","title":"Combining values"},{"location":"introduction/#if-statements","text":"Are useful for when you for example get some numbers in your data that are supposed to represent different types.","title":"If statements"},{"location":"introduction/#simple-if-statement","text":"Let's check if the value equals 1 and output type_one . config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"readable_type\" , \"mappings\" : [ { \"path\" : [ \"type\" ], \"if_statements\" : [ { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"type_one\" } ] } ] } ] } input.json { \"type\" : \"1\" } output.json { \"readable_type\" : \"type_one\" } If statements are really useful for changing the values depending on some condition. Check the list of supported conditions. otherwise can also be used to specify should happen if the condition is false . If otherwise is not provided then output will be the original value.","title":"Simple if statement"},{"location":"introduction/#chain-if-statements","text":"if_statements is a list of if statement objects. We designed it like this so that we can chain them. The output of the first one will be the input of the next one. the mapping object is not the only one that can have if statements, the attribute can also have them. This allows for some interesting combinations. config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"readable_type\" , \"mappings\" : [ { \"path\" : [ \"type\" ], \"if_statements\" : [ { \"condition\" : \"is\" , \"target\" : \"1\" , \"then\" : \"boring-type\" }, { \"condition\" : \"is\" , \"target\" : \"2\" , \"then\" : \"boring-type-two\" , \"otherwise\" : \"fun-type\" }, { \"condition\" : \"contains\" , \"target\" : \"fun\" , \"then\" : \"funky_type\" } ] } ], \"if_statements\" : [ { \"condition\" : \"not\" , \"target\" : \"funky_type\" , \"then\" : \"junk\" , \"otherwise\" : \"funk\" } ] } ] } input.json { \"type\" : \"1\" } output.json { \"readable_type\" : \"funk\" } input2.json { \"type\" : \"2\" } output2.json { \"readable_type\" : \"junk\" } Using input.json the places that are highlighted is everywhere the value changes. For input2.json the first if statement is false and no value change. The second if statement is true so value is changed to boring-type-two . The third if statement is false so no value change. The last if statement checks if the value is not funky_type which is true, so the value is changed to junk . You can even add if statements for every mapping object you add into mappings so this can handle some quite complicated condition with multiple values.","title":"Chain If Statements"},{"location":"introduction/#casting-values","text":"You've learned how to structure your output with objects, find values and asigning them to attributes, combining values and applying if statements. Its now time to learn how to cast values. Casting values is very useful for when we get string(text) data that should be numbers. Or when you get badly(non-iso) formatted date values that you want to change to ISO dates Casting is straightforward. You map your value like you would and then add the casting object.","title":"Casting values"},{"location":"introduction/#casting-to-decimal","text":"config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"my_number\" , \"mappings\" : [ { \"path\" : [ \"string_number\" ] } ], \"casting\" : { \"to\" : \"decimal\" } } ] } input.json { \"string_number\" : \"123.12\" } output.json { \"my_number\" : 123.12 }","title":"Casting to decimal"},{"location":"introduction/#casting-to-iso-date","text":"When casting to a date we always have to supply the original_format which is the format that the input data is on. without knowing this there would be know way to know fore sure in every case if it was dd.mm.yy or yy.mm.dd config.json { \"name\" : \"root\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"my_iso_date\" , \"mappings\" : [ { \"path\" : [ \"yymmdd_date\" ] } ], \"casting\" : { \"to\" : \"date\" , \"original_format\" : \"yymmdd\" } } ] } input.json { \"yymmdd_date\" : \"101020\" } output.json { \"my_iso_date\" : \"2010-10-20\" } Check our the configuration docs on casting for more info","title":"Casting to ISO Date"},{"location":"introduction/#working-with-lists","text":"Finally! Last topic and the most interesting one! Usually the data that you are processing is not one thing, but a list of things(data). We want to iterate the list and for each and every piece of data in that list we want to transform it. This is the section that lets you do that. Lets say we are creating a website for an RPG game that dumps its data in a flat format. Every line is a player with a name , class , money , and x , y coordinates for where he is in the world. data.json { \"data\" : { \"something_uninteresting\" : [ 1 , 2 , 3 ], \"character_data\" : [ [ \"SuperAwesomeNick\" , 1 , 500 ], [ \"OtherAwesomeDude\" , 2 , 300 ], [ \"PoorDude\" , 2 , 10 ] ] } } Now to make the frontend dudes happy we would liketo structure this nicely... something like: { \"players\" : [ { \"nickname\" : \"SuperAwesomeNick\" , \"class\" : \"warrior\" , \"gold\" : 500 , }, { \"nickname\" : \"OtherAwesomeDude\" , ... } ] }","title":"Working with lists"},{"location":"introduction/#introducing-path-to-iterable","text":"We can use path_to_iterable on an object which works similar to mapping.path , but it applies the current object and all its attrbute mappings and nested objects to each and every element in whatever list path_to_iterable points to. Lets solve the above example! config.json { \"name\" : \"root\" , \"array\" : false , \"objects\" : [ { \"name\" : \"players\" , \"array\" : true , \"path_to_iterable\" : [ \"data\" , \"character_data\" ], \"attributes\" : [ { \"name\" : \"nickname\" , \"mappings\" : [ { \"path\" : [ \"character_data\" , 0 ] } ] }, { \"name\" : \"class\" , \"mappings\" : [ { \"path\" : [ \"character_data\" , 1 ] } ], \"if_statements\" : [ { \"condition\" : \"is\" , \"target\" : 1 , \"then\" : \"warrior\" , \"otherwise\" : \"cleric\" } ] }, { \"name\" : \"gold\" , \"mappings\" : [ { \"path\" : [ \"character_data\" , 2 ] } ] } ] } ] } input.json { \"data\" : { \"something_uninteresting\" : [ 1 , 2 , 3 ], \"character_data\" : [ [ \"SuperAwesomeNick\" , 1 , 500 ], [ \"OtherAwesomeDude\" , 2 , 300 ], [ \"PoorDude\" , 2 , 10 ] ] } } output.json { \"players\" : [ { \"nickname\" : \"SuperAwesomeNick\" , \"class\" : \"warrior\" , \"gold\" : 500 }, { \"nickname\" : \"OtherAwesomeDude\" , \"class\" : \"cleric\" , \"gold\" : 300 }, { \"nickname\" : \"PoorDude\" , \"class\" : \"cleric\" , \"gold\" : 10 } ] } Note that we still have to reference the key when mapping. The key name( character_data ) is the last name in the list of path_to_iterable . And thats it! Congratulations the introduction course is done! Time to map some data and have fun doing it!","title":"Introducing Path to Iterable"},{"location":"test-swagger/","text":"window.onload = function() { const ui = SwaggerUIBundle({ url: \"https://github.com/greenbird/piri/blob/master/mapmallow/schema.json\", dom_id: '#swagger-ui', presets: [ SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset ] }) window.ui = ui } extra_css : - stylesheets/swagger-ui.css extra_javascript : - javascripts/swagger-ui-bundle.js - javascripts/swagger-ui-standalone-preset.js","title":"Test swagger"},{"location":"usage/","text":"The goal of this library is to make configurable data transformation(mapping) easy and flexible. We have decided to only support json to json mapping. This is because quite frankly its impossible to have configurable mapping that works on any format. We chose json because its quite easy to make anything into json and its quite easy to make json into anything. When we made this library we have dealt primarily with csv data or xml data. example csv file could looks something like this: thomas;borgen;street123;1010;20-10-10;500 john;doe;street124;1011;20-10-11;6000 which would easily be turned in a json file looking like this: { \"data\" : [ [ \"thomas\" , \"borgen\" , \"street123\" , \"1010\" , \"19-10-2020\" , \"500\" ], [ \"john\" , \"doe\" , \"street124\" , \"1011\" , \"20-10-2020\" , \"6000\" ], ] } Lets say we want to map this into a structure like this [ { \"name\" : \"firstname lastname\" , \"address\" : { \"street\" : \"street\" , \"zip\" : \"zipcode\" }, \"invoice\" : { \"due_date\" : \"isodate\" , \"amount\" : 10.0 } } ] Then we'd use a configuration that you will see is structurally quite similar to the output that we want. { \"name\" : \"root\" , \"array\" : true , \"path_to_iterable\" : [ \"data\" ], \"attributes\" : [ { \"name\" : \"name\" , \"mappings\" : [ { \"path\" : [ \"data\" , 0 ] }, { \"path\" : [ \"data\" , 1 ] } ], \"separator\" : \" \" } ], \"objects\" : [ { \"name\" : \"address\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"street\" , \"mappings\" : [ { \"path\" : [ \"data\" , 2 ] } ] }, { \"name\" : \"zip\" , \"mappings\" : [ { \"path\" : [ \"data\" , 3 ] } ] } ] }, { \"name\" : \"invoice\" , \"array\" : false , \"attributes\" : [ { \"name\" : \"due_date\" , \"mappings\" : [ { \"path\" : [ \"data\" , 4 ] } ], \"casting\" : { \"to\" : \"date\" , \"original_format\" : \"dd.mm.yyyy\" } }, { \"name\" : \"amount\" , \"mappings\" : [ { \"path\" : [ \"data\" , 5 ] } ], \"casting\" : { \"to\" : \"decimal\" } } ] } ] } which will produce [ { \"name\" : \"thomas borgen\" , \"address\" : { \"street\" : \"street123\" , \"zip\" : \"1010\" }, \"invoice\" : { \"due_date\" : \"2020-10-20\" , \"amount\" : 500.0 } }, { \"name\" : \"john doe\" , \"address\" : { \"street\" : \"street124\" , \"zip\" : \"1011\" }, \"invoice\" : { \"due_date\" : \"2020-10-19\" , \"amount\" : 6000.0 } } ]","title":"Usage"},{"location":"usecases/usecases/","text":"In this section we try to explain some normal usecases for Piri . It is highly recommended that you go through the introduction before continuing Piri + CSV \u00b6 CSV is one of the most used filetypes when exchanging data by files. Here are some examples to look at when working with csv Transform CSV data to JSON Transform JSON to CSV Row Type CSV data Piri + XML \u00b6 XML is... ugh... but a lot of legacy systems expect XML as input and produces XML as output. We won't get rid of XML anytime soon, but atleast with piri we can live with it. There are three things to look out for when working with XML. It's impossible to know if a child of an element is supposed to be an array or not. XML creates structure with Elements, but store data as either parameters or as text between element opening and closing tag. Because of this there are no 1 to 1 XML->JSON converter that will work for any XML. Conventions must be chosen but a good starting point is the Parker convention Restructure XML data with Piri From XML to CSV CSV to XML Other usecases \u00b6 Add an issue at our issue tracker for request for other usecases/examples","title":"Usecases"},{"location":"usecases/usecases/#piri-csv","text":"CSV is one of the most used filetypes when exchanging data by files. Here are some examples to look at when working with csv Transform CSV data to JSON Transform JSON to CSV Row Type CSV data","title":"Piri + CSV"},{"location":"usecases/usecases/#piri-xml","text":"XML is... ugh... but a lot of legacy systems expect XML as input and produces XML as output. We won't get rid of XML anytime soon, but atleast with piri we can live with it. There are three things to look out for when working with XML. It's impossible to know if a child of an element is supposed to be an array or not. XML creates structure with Elements, but store data as either parameters or as text between element opening and closing tag. Because of this there are no 1 to 1 XML->JSON converter that will work for any XML. Conventions must be chosen but a good starting point is the Parker convention Restructure XML data with Piri From XML to CSV CSV to XML","title":"Piri + XML"},{"location":"usecases/usecases/#other-usecases","text":"Add an issue at our issue tracker for request for other usecases/examples","title":"Other usecases"}]}